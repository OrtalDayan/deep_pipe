# configs
from .assets.core import *
from .assets.problem.msegm_base import *
from .assets.batch_iter.patch_3d import *
# from .assets.model.tnet3d import *
from .assets.dataset.isles15 import *
# modules
import torch
from dpipe.batch_predict.patch_3d_fixed import Patch3DFixedDropoutPredictor
from dpipe.torch.utils import bce_logits as logits2loss
from dpipe.medim import metrics
from dpipe.train.train import train as train_function
from dpipe.train.validator import validate

from dpipe.model_core.tnet_with_dropout import TNet3d_with_dropout
from dpipe.torch.model import TorchModel, TorchFrozenModel

model_core = TNet3d_with_dropout(
    n_chans_in=n_chans_in,
    n_chans_out=n_chans_out,
    structure=structure,
    stride=stride,
    activation=activation
)

model = TorchModel(
    model_core=model_core,
    logits2pred=logits2pred,
    logits2loss=logits2loss,
    optimize=optimize
)

frozen_model = TorchFrozenModel(
    model_core=model_core,
    logits2pred=logits2pred,
    restore_model_path=restore_model_path,
)

data_path = "/nmnt/x04-hdd/ISLES/"

# model
structure = [
    [[16, 16], [], [48, 48]],
    [[32, 64, 32]],
]
stride = 2
activation = torch.nn.ReLU(inplace=True)
logits2pred = torch.nn.Sigmoid()
optimize = torch.optim.Adam

# train and evaluation
batch_size = 2
n_iters_per_batch = 2
n_epochs = 2

y_patch_size = [51, 51, 51]
x_patch_sizes = [y_patch_size]

batch_predict = Patch3DFixedDropoutPredictor(
    x_patch_sizes=x_patch_sizes,
    y_patch_size=y_patch_size,
    padding_mode="min",
)

multiple = {
    "max_dice": metrics.calc_max_dices
}

train = train_function(
    # lazy
    atol=0.01,
    lr_dec_mul=0.7,
    lr_init=0.01,
    n_epochs=n_epochs,
    patience=5,
    rtol=0.03,
    log_path=console.log_path,

    validator=validate(
        # lazy
        load_x=load_x,
        load_y=load_y,
        ids=val_ids,
        multiple=multiple
    ),

    model=model,
    train_batch_iter_factory=batch_iter_factory,
    batch_predict=batch_predict,
)
